#pragma once
#include <string>
#include <vector>
using namespace std;

const vector<string> operations2children = { "+", "-", "*", "/" };
const vector<string> operations1child = { "sin", "cos" };
const int multiplicationIndex = 2;
const int divisionIndex = 3;
const int IDconstant = 3;
const int IDvariable = 4;
const char minDigit = '0';
const char maxDigit = '9';
const char decimalSeparator = '.';
const char quotationMark = '"';
const char minSmalLetter = 'a';
const char maxSmallLetter = 'z';
const char minCapitalLetter = 'A';
const char maxCapitalLetter = 'Z';
const string defaultNodeValue = "1";
const string emptyString = "";
const string endLine = "\n";
const string space = " ";
const string openingBracket = "(";
const string closingBracket = ")";
const int baseNumber = 10;
const int maxChildrenCount = 2;


template <typename T> class CNode
{

private:
	vector<CNode*> children;	// vector with children
	CNode* parent;				// parent of root is NULL
	string value;				// operation or constant or variable
	int type;					// 1 - operation with 1 child, 2 - operation with 2 children, 3 - constant, 4 - variable
	static string errMsg;						// error messages generated by all the nodes
	static int getType(string* value);			// return type of a string (operation, constant or variable), if its a variable, turns it into a valid variable name
	static bool isNumber(const string value);	// return true if string is a number
	static string validateVariableName(const string value);			// turn string into a valid variable name
	static double strToNumber(const string value, bool* overflow);	// convert string to int

public:

	CNode(const vector<string> expression, CNode<T>* parent, int* index);	//Constructor from a string at index (calls next constructor)
	vector<string> inOrderWalk(vector<string>* accumulator) const;			// return expression used to create the tree
	vector<string> getVars(vector<string>* accumulator) const;				// return expression used to create the tree
	static T calculate(CNode<T>* node, const vector<string> vars, const vector<T> values); // calculate expression using variables and values
	void deleteTree() noexcept;						// delete all children and itself
	static void logError(string msg);		// add error message
	static void logErrorSpace(string msg);	// add error message terminated with a space instead of a newline
	static string getErrors(bool clear);	// return all error messages and clear them if flag is set
};


template <typename T> class CTree
{

private:
	CNode<T>* root;

public:
	CTree();													//Default constructor - empty tree
	CTree(const CTree& otherInstance);							//Copy constructor
	CTree(CTree&& otherInstance) noexcept;						//Move constructor - move another tree to created tree
	CTree(const vector<string> expression);						//Constructor from a vector of strings 

	void operator=(const CTree& otherInstance);					//Set current tree to a copy of another tree
	void operator=(CTree&& otherInstance) noexcept;				//Move operator - move another tree to current tree
	CTree operator+(const CTree& otherInstance) const;			//Return copy, result of adding another tree to current tree

	string getErrors() const;									//Return all errors generated by nodes
	string clearErrors();										//Clear all errors generated by nodes and clear them
	vector<string> getExpression() const;						//Return expression used to create the tree
	vector<string> getVars() const;								//Print all variables used in the expression
	T calculate(vector<string> command) const;					//Calculate expression using variable values
	inline bool isInitialized() const { return root != NULL; }; //Check if tree is initialized

	~CTree(); //Destructor
};

#pragma once
